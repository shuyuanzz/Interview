# Interview
前端面试总结
### <a href="# js部分"></a>
### <a name="js部分"></a>
1. js的数据类型  

js总共有六种基本数据类型————Undefined Null Boolean String Symbol(Es6新增的一种类字符串类型，来表示一种独一无二的值)，还有一种复杂数据类型Object（也可以说是引用数据类型）。  

二者的区别：  
基本类型的值储存在栈内存中，引用类型的值储存在堆内存中，在赋值过程中，基本类型（值类型）是将值赋值给变量。而引用类型是将指向该值的指针（存储在栈内存中）赋值给变量，从而导致如下结果
```
// 基本类型
var a = 10
var b = a
b = 20
console.log(a)  // 10
console.log(b)  // 20
//复制代码上述代码中，a b都是值类型，两者分别修改赋值，相互之间没有任何影响。再看引用类型的例子：
// 引用类型
var a = {x: 10, y: 20}
var b = a
b.x = 100
b.y = 200
console.log(a)  // {x: 100, y: 200}
console.log(b)  // {x: 100, y: 200}
//复制代码上述代码中，a b都是引用类型。在执行了b = a之后，修改b的属性值，a的也跟着变化。因为a和b都是引用类型，指向了同一个内存地址，即两者引用的是同///一个值，因此b修改属性时，a的值随之改动
```
2. 数据类型的判断  

1）type of 返回一个表示数据类型的字符串(主要用来检测基本类型，除了`type of null //undifined` 和 `type of Function  = Function`之外其它基本数据类型正常返回，复杂数据类型全部都为Object)  

2） nstance of:  （用来检测引用类型）
如果给定的类型是引用类型 instanceof 是根据原型链去识别，如果给定的类型是基本类型，instanceof会永远返回false  

3）也可以通过constructor去检测，但是constructor是有可能被覆盖和重写的，有一定的不准确性  

4）Object.prototype.toString.call()，最准确最常用的方式

3. 浅拷贝深拷贝
浅拷贝只复制指向某个对象的指针，而不是赋值这个对象本身，新旧变量还是共享的同一块堆内存。
浅拷贝实现方式  
```
Object.assign()：需注意的是目标对象只有一层的时候，是深拷贝
Array.prototype.concat()
Array.prototype.slice()
```
而深拷贝是直接开辟一个新的堆内存空间去复制整个对象的值
深拷贝实现方式
```
lodash _.cloneDeep方法;
JSON.parse(JSON.stringify());
手写一个递归方法
```

4. 执行上下文和执行栈
执行上下文就是js代码被解析和执行时所在的环境的抽线概念，js中执行的任何代码都时在执行上下文中运行，执行上下文的生命周起包括创建阶段，执行阶段，回收阶段  

1） 创建阶段  
创建变量对象
创建作用域链
确定this指向
这是因为当函数执行的时候,首先会形成一个新的私有的作用域，然后依次按照如下的步骤执行：

如果有形参，先给形参赋值
进行私有作用域中的预解释，函数声明优先级比变量声明高，最后后者会被前者所覆盖，但是可以重新赋值
私有作用域中的代码从上到下执行 


函数多了，就有多个函数执行上下文，每次调用函数创建一个新的执行上下文，那如何管理创建的那么多执行上下文呢？
JavaScript 引擎创建了执行栈来管理执行上下文。可以把执行栈认为是一个存储函数调用的栈结构，遵循先进后出的原则。  

从上面的流程图，我们需要记住几个关键点：  

JavaScript执行在单线程上，所有的代码都是排队执行。
一开始浏览器执行全局的代码时，首先创建全局的执行上下文，压入执行栈的顶部。
每当进入一个函数的执行就会创建函数的执行上下文，并且把它压入执行栈的顶部。当前函数执行完成后，当前函数的执行上下文出栈，并等待垃圾回收。
浏览器的JS执行引擎总是访问栈顶的执行上下文。
全局上下文只有唯一的一个，它在浏览器关闭时出栈。

5. 作用域和作用域链  

在ES6之前就只有两个作用域： 函数作用域和全局作用域，ES6新增了块级作用域 （let,const 的出现）。
作用域就可以比作是一个独立的地盘，里面的变量外面访问到，这样的话可以用来防止命名冲突。  
访问变量 是一个由内而外的过程（在本作用域没有找到就去外面的一层作用域里面去找） 这里有一个自由变量的概念 作用域中使用到了 在本作用域中没有定义的变量（在作用域外面定义了）就叫做自由变量 这个由内而外的过程类似于一个链结构一样，这就是作用域链。

6. 闭包

当一个函数它的返回值是另外一个函数时，并且另外一个函数使用到了它的父级函数的参数或者变量，这种方式就叫做闭包。

好处：封装私有变量，隔离作用域。
坏处：当父级函数运行完后，有些变量的内存空间无法得到释放，当闭包嵌套过深会导致内存占用过大的问题，也有可能会导致内存泄漏（最好的办法当返回的函数执行完后将变量指向null）。  

7. this的指向问题

总体概况就是谁调用就指向谁（function调用 function this指向window），可通过 call apply bind来改变this指向。

8. EventLoop
常见的宏任务和微任务
宏任务：script(整体代码)、setTimeout、setInterval、I/O、事件、postMessage、 MessageChannel、setImmediate (Node.js)
微任务：Promise.then、 MutaionObserver、process.nextTick (Node.js)
1.执行栈所有的同步任务都在主线程执行 2.异步任务会在异步处理模块执行，执行后的回调函数放入任务队列 3. 执行栈空后，会将任务队列中的第一个任务压入执行栈中执行 4.不断重复第三步（也就是说至主线程空了就不断执行第三部）

先执行同步代码，和异步代码不是回调的部分（如果遇到宏任务就将该任务压入宏任务队列） 将异步代码的回调部分放入微任务队列中，等执行栈中的所有任务执行完后，开始执行微任务队列中的代码，等微任务队列中的任务执行完后，最后执行宏任务的代码。

9. async await
其中 await 前面的代码 是同步的，调用此函数时会直接执行；而 await bar(); 这句可以被转换成 Promise.resolve(bar())；await 后面的代码 则会被放到 Promise 的 then() 方法里。因此上面的代码可以被转换成如下形式，这样是不是就很清晰了？
function foo() {
  // await 前面的代码
  Promise.resolve(bar()).then(() => {
    // await 后面的代码
  });
}

function bar() {
  // do something...
}

foo();

10.  原型和原型链
每一个构造函数都有一个prototype的对象，也就是原型对象，原型对象里面会自动生成一个constructor（构造函数） 它指向构造函数本身。
```
function Shu () {

}
let yuan = new shu ();
```
这样的话yuan可以通过一个叫做_proto_ 的指针来访问 Shu的原型对象，这样一次连接就形成了一条链。
这就是原型链；

11. 继承

查看inherit.js

